=================================
vaporEngine - whats the big deal?
=================================
:Author: João Matos <triton@portugal-a-programar.com>
:Description: vaporEngine documentation
:Info: reStructeredText format rocks.

Structure
=========

So, vaporEngine is just a KISS 3D engine I've been working on in the past few months.

Features
========

	* Cross-platform engine (Windows for now)
	* Clean architecture using modern C++
	* Modern (no fixed-function pipeline!)
	* Multiple renderers (OpenGL only for now)
	* Don't reinvent the wheel (lots of cool libs)

Architecture
============

The engine is divided in a few subsystems:

	* platform  (file, memory, time, dynlib, log, vfs)
	* math		(vectors, matrices, AABBs, ...)
	* render	(opengl, directx, software)
	* scene		(scene graph, bvh, ...)
	* resources	(textures, meshes, fonts, audio, video)
	* input		(mouse, keyboard)
	* physics	(collision detection)
	
Rendering classes
=================

Queue

	this holds references to all the scene entities we are to render.
	it sorts them by state (materials, opacity) to minimise state changes.

Device
	
	represents the rendering device we are using. at startup the application
	can ask the user what device he wants to use (OpenGL / DirectX / Software)
	and then we create and use the device. all operations are to be done by this
	abstract class. the user of the engine doesnt need to care about details.
	this class only knows about rendering primitives (VertexBuffer and IndexBuffer) 
	and does not know anything about the high-level mesh/models.
	
	each render device will also have a list of render targets (windows or RTT).
	and a specific Window implementations depend on the rendering system used. 
	for example, an opengl window will be different from an directx window.
	it is responsible for creating a new window if no window is passed to it.

Adapter

	the adapter class just represents a video card entity, and holds everything
	that has to do with it and is interesting for the other classes, like driver
	information and the capabilities. obviously this depends on the rendering
	device the app is using at run time, so there is a specific derived class
	for each rendering device supported.

Window

	just a class that has the window we are to render. this is abstract and could
	have a subclass for every other operating system / graphics api we are to support. 
	right now it uses SDL for creating and managing windows.
	
Target

	each render target has a render queue that will be filled up by the camera 
	once it is done with frustum culling.

BufferManager

	responsible to give out buffers

Camera

	the camera class points to what the user is looking at. it is used to configure 
	the type of projection we need and also handles the frustum culling operations.
	the camera connects the scenemanager/renderqueue.
	
Renderable

	a renderable object needs to have a couple of things, like at least one vertexbuffer
	and one indexbuffer, because that is only what the device understands.
	
Scene classes
=============

SceneManager


Resource classes
================

Font

Mesh

Image

ResourceManager

	this class will hold references to all the resource in use by the application.
	these resources can be loaded at runtime using its interface. it holds the
	resources in groups. one can register resource loaders at runtime to let the
	resource manager know what can decode each type of resource. the user of the
	engine only needs to create resources passing a path and they will be auto-
	-matically handled by the manager.