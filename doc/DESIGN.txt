=================================
vaporEngine - whats the big deal?
=================================
:Author: João Matos <triton@portugal-a-programar.com>
:Description: vaporEngine documentation
:Info: reStructeredText format rocks.

Structure
=========

So, vaporEngine is just a tiny KISS 3D engine I've been working on in the past few months.

The engine is divided in a few subsystems (enclosed in namespaces):

	* log		(logging)
	* vfs		(virtual file system)
	* math		(vectors, matrices, AABBs, ...)
	* scene		(scene graph, bvh, ...)
	* render	(opengl, directx, software)
	* resources	(textures, meshes, fonts, ...)
	* input		(mouse, keyboard, ...)
	* audio		(vorbis, mo3)
	* video		(theora, ffmpeg)
	* physics	(collision detection)

Rendering classes
=================

Queue

	this holds references to all the scene entities we are to render.
	it sorts them by state (materials, opacity) to minimise state changes.

Device
	
	represents the rendering device we are using. at startup the application
	can ask the user what device he wants to use (OpenGL / DirectX / Software)
	and then we create and use the device. all operations are to be done by this
	abstract class. the user of the engine doesnt need to care about details.
	this class only knows about rendering primitives (VertexBuffer and IndexBuffer) 
	and does not know anything about the high-level mesh/models.
	
	each render device will also have a list of render targets (windows or RTT).
	and a specific Window window implementations depend on the rendering system used. 
	for example, an opengl window will be different from an directx window.
	it is responsible for creating a new window if no window is passed to it.

Adapter

	the adapter class just represents a video card entity, and holds everything
	that has to do with it and is interesting for the other classes, like driver
	information and the capabilities. obviously this depends on the rendering
	device the app is using at run time, but i still have to check if i will
	need different classes for different render devices. hopefully not. 

Window

	just a class that has the window we are to render. this is abstract and will
	have a subclass for every other operating system / graphics api we are to support. 
	right now it uses SDL for creating and managing windows but it creates a dependency 
	and should be replaced by native code / alternative lib.
	
	each render target has a render queue that will be filled up by the camera 
	once it is done with frustum culling.

BufferManager

	responsible to give out buffers

Camera

	the camera class points to what the user is looking at. it is used to configure 
	the type of projection we need and also handles the frustum culling operations.
	the camera connects the scenemanager/renderqueue.
	
Renderable

	a renderable object needs to have a couple of things, like at least one vertexbuffer
	and one indexbuffer, because that is only what the device understands.
	
Scene classes
=============

SceneManager


Resource classes
================

Font

Mesh

Texture

ResourceManager

	this class will hold references to all the resource in use by the application.
	these resources can be loaded at runtime using the ResourceManager interface.