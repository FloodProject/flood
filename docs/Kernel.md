Runtime Kernel
--------------

This is the lowest layer of the software, and solves a couple
of low-level common problems when developing software in C++.

* Packages

Packages are the unit of deployment for extensions, and provide
modules, resources and metadata. A package functions like an
archive, and can provide a cryptographic checksum / signature
so its authenticity can be verified when being loaded.

* Modules

Modules are the executable code itself that is contained inside
packages. They can be native or managed code. This allows managed
extensions that depend on native shared objects to be deployed
in a cross platform manner.

* Resources

Every complex piece of software needs to distribute various kinds
of resources, from artwork to configuration files. Resources can
be distributed inside packages to be reused by modules. Since they
are part of a package they can also be updated.

* Reflection / Serialization

Native modules can provide their own introspection metadata. This
can be very useful for runtime code reloading, automatic serialization,
and debugging tools. This data is generated by a robust Clang-based
C++ parser and written to an external file that can be loaded at
runtime if the information is needed.

* Memory Management

Each module is required to allocate memory through a specific interface,
this means that we can accurately track all the memory that has been
allocated on the system and even provide real time tools to view this
information.

* Error Handling

The low level layer is responsible for setting up an adequate error handling
strategy. This means that when native / managed code crashes we are able to
intercept it and handle it in a reasonable way. This might mean restarting
a piece of managed code, reporting the problem, saving a callstack, etc.

* Scripting

Since native code has many disadvantages for higher level functionality,
we provide a managed language runtime (based on Mono) that allows access
to all the services provided by the native modules.

* Remote Object Invocation


Similiar systems
----------------

Kroll
https://github.com/appcelerator/kroll

	Kroll is a compact microkernel written in C++ for running pluggable
	modules. Kroll supports a cross-language, cross-platform "binding" and
	invocation framework which supports mixing and matching code within the
	Kroll kernel.


XPCOM
https://developer.mozilla.org/en-US/docs/XPCOM

	XPCOM (Cross Platform Component Object Model) is a cross-platform component
	model from Mozilla. It is similar to Microsoft COM and CORBA. It features
	multiple language bindings and IDL descriptions thus programmers can plug
	their custom functionality into the framework and connect it with other
	components.


GObject / GObject Introspection
http://developer.gnome.org/gobject/stable/
https://live.gnome.org/GObjectIntrospection/

	GObject is a free software library providing a portable object system and
	transparent cross-language interoperability. GObject is designed for use both
	directly in C programs to provide object-oriented C-based APIs and through
	bindings to provide transparent cross-language interoperability.


COM
http://msdn.microsoft.com/en-us/library/ms680573(v=vs.85)

	COM is a platform-independent, distributed, object-oriented system for creating
	binary software components that can interact. COM is the foundation technology
	for Microsoft's OLE (compound documents) and ActiveX technologies.


CLI
http://msdn.microsoft.com/en-us/library/12a7a7h3(v=vs.110).aspx

	The Common Language Infrastructure (CLI) is an open specification developed
	by Microsoft that describes the executable code and runtime environment that
	form the core of the .NET Framework. The specification defines an environment
	that allows multiple high-level languages to be used on different computer
	platforms without being rewritten for specific architectures.


Serialization / RPC frameworks
------------------------------

Protobufs (http://code.google.com/p/protobuf/)

	Protocol Buffers are a way of encoding structured data in an efficient yet
	extensible format. Google uses Protocol Buffers for almost all of its internal
	RPC protocols and file formats.

Thrift (http://thrift.apache.org/)

	The Apache Thrift software framework, for scalable cross-language services
	development, combines a software stack with a code generation engine to build
	services that work efficiently and seamlessly between C++, Java, Python, PHP,
	Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml
	and Delphi and other languages.

MessagePack (http://msgpack.org/)

	MessagePack is an efficient binary serialization format. It lets you exchange
	data among multiple languages like JSON but it's faster and smaller.
	For example, small integers (like flags or error code) are encoded into a single
	byte, and typical short strings only require an extra byte in addition to the
	strings themselves.

Ice (http://www.zeroc.com/overview.html)

	Ice is more than just an RPC platform. Besides fully-featured and high-performance
	RPC, Ice provides a number of services. These services supply functionality that
	most distributed applications require, such as event distribution or persistence.


Reflection
----------

clReflect (http://donw.org/b/?d=clReflect)

	clReflect uses the incredible clang frontend for LLVM to parse C++ and
	automatically derive a light-weight Reflection database that can be loaded
	and used as you please at runtime.

Binary compatibility
--------------------

To achieve binary compatibility between versions, external components have to
communicate via interfaces, else the implementation details of the services
will leak to the code consuming the services (and the components themselves
need to be linked to the libraries that implement those services).

Managed components don't have this problem since all the ABI details are managed
at runtime by the binding runtime system. As long as the interface is the same,
even if the binary compatibility of the native class changes, the managed code
will not be affected.

COM and XPCOM solve this problem by defining interfaces in an external interface
definition language (IDL). Stubs can then be generated by an external tool,
either for comsumption or implementation of the declared services.

There is also the option of generating a type library from the interfaces, which
just stores the metadata related to the types and interfaces declared in IDL.
This is equivalent to reflection, and allows tools that process COM objects more
flexibility since they can introspect all the services provided by the objects.

COM-like systems like XPCOM and GObject solve this problem

Using managed services from native code

Using native services from managed code










